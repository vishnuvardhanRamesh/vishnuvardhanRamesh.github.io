<!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="utf-8" />

  <title></title>


  <meta name="author" content="Vishnuvardhan Ramesh"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />


<link rel="stylesheet" href="//localhost:1313/css/latex.css" />
<link rel="stylesheet" href="//localhost:1313/css/main.css" />
<script id="MathJax-script" async src="//localhost:1313/js/tex-mml-chtml.js"></script>
</head>
<body>






<div class="intro-header"></div>
<div id="content">
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <div class="postmeta">
        <span class="meta-post">
  <i class="fa fa-calendar-alt"></i>
  Jan 1, 0001
  
</span>
      </div>
      <br>
      
    <!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="utf-8" />

  <title></title>


  <meta name="author" content="Vishnuvardhan Ramesh"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />


<link rel="stylesheet" href="//localhost:1313/css/latex.css" />
<link rel="stylesheet" href="//localhost:1313/css/main.css" />
<script id="MathJax-script" async src="//localhost:1313/js/tex-mml-chtml.js"></script>
</head>
<body>






<div class="intro-header"></div>
<div id="content">
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <div class="postmeta">
        <span class="meta-post">
  <i class="fa fa-calendar-alt"></i>
  Jan 1, 0001
  
</span>
      </div>
      <br>
      
    <!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="utf-8" />

  <title></title>


  <meta name="author" content="Vishnuvardhan Ramesh"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />


<link rel="stylesheet" href="//localhost:1313/css/latex.css" />
<link rel="stylesheet" href="//localhost:1313/css/main.css" />
<script id="MathJax-script" async src="//localhost:1313/js/tex-mml-chtml.js"></script>
</head>
<body>






<div class="intro-header"></div>
<div id="content">
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <div class="postmeta">
        <span class="meta-post">
  <i class="fa fa-calendar-alt"></i>
  Jan 1, 0001
  
</span>
      </div>
      <br>
      
    <!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="utf-8" />

  <title>HTAX Verification - SystemVerilog/UVM - </title>


  <meta name="author" content="Vishnuvardhan Ramesh"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />


<link rel="stylesheet" href="//localhost:1313/css/latex.css" />
<link rel="stylesheet" href="//localhost:1313/css/main.css" />
<script id="MathJax-script" async src="//localhost:1313/js/tex-mml-chtml.js"></script>
</head>
<body>






<header>
  <nav class="navbar">
  <div class="nav">
    

    <ul class="nav-links">
      
    </ul>
  </div>
</nav>
  <div class="intro-header">
    <div class="container">
      <div class="post-heading">
        
          <h1>HTAX Verification - SystemVerilog/UVM</h1>
          
        
      </div>
    </div>
  </div>
</header>
<div id="content">
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <div class="postmeta">
        <span class="meta-post">
  <i class="fa fa-calendar-alt"></i>
  Nov 10, 2024
  
</span>
      </div>
      <br>
      
    <p>Hardware verification is a integral part of the chip design process. Failures to catch defects can cost millions of dollars for companies. Software bugs can often be patched with a quick update, but most hardware faults can only be fixed by recalling the chip and replacing it.</p>
<p>Because of this, Verification Engineers are often employed by companies for the sole purpose of debugging and catching errors in the design before final chip tape out.</p>
<p>A typical verification cycle goes through the following steps:</p>
<ol>
<li><strong>Functional Specification</strong>: Describes what functions the design performs, as well as any interfaces for module specification. This is typically implemented in HDL by design engineers.</li>
<li><strong>Verification Plan</strong>: List functions to be verified, specific tests/methods, measurements to indicate completed verification, and estimate of verification cost</li>
<li><strong>Verification Environment</strong>: Build a set of software code that allows engineers to easily find and debug errors in HDL code.</li>
<li><strong>Run Regression</strong>: Run tests defined in the verification plan to uncover <em>hard to find</em> bugs and ensure that coverage goals have been met</li>
<li><strong>Coverage Analysis</strong>: Check for functional and code coverage, as well as assertions</li>
</ol>
<p>These steps are just an overview to the verification process, but they entail the basics of how engineers find and debug errors in chip design.</p>
<p>The rest of the article describes the verification of the <a href="https://drive.google.com/file/d/1btEmv-M3NiU0EfXjCkvxFGIwOvoqm19v/view">HyperTransport Advanced X-Bar</a> module, a communication protocol that can be used for transmitting/receiving signals between chips. This includes the following:</p>
<ul>
<li>Verification plan (using Cadence vManager)</li>
<li>Verification environment including: UVM Interface, sequences, monitor, agent, and scoreboard</li>
<li>SystemVerilog Assertions and coverage checkers for regression testing</li>
</ul>
<h2 id="verification-plan">Verification Plan</h2>
<p>The verification plan specifies <em>what</em> is being verified, and <em>how</em> the verification is done. All engineers
are involved in this process, both from the design and verification team. The most important part of the plan is <em>following the specifications</em>, so that issues between the two teams can be resolved. In the case of the HTAX communication protocol, planning was split into three categories: testcases, asssertions, and functional coverage</p>
<p>Testcases are very specific scenarios that test the design under unique circumstances. These are typically the backbone of verification and allows for coverage goals to be met, and assertions to be verified. Each testcase typically has a brief name and description. Examples include the following:</p>
<ul>
<li>Transmission Port-to-Port test (from port X to port Y)</li>
<li>Short data packet length test (length between 3 to 10 bytes)</li>
<li>Double transmit request utilizing minimum latency (Single virtual channel request)</li>
</ul>
<p>Assertions are statements that check the state of the design at various points during simulation. For example, if there is a register that is coded to always be zero, an assertion can be made that will raise an error if the register contains a non-zero value at any point during the simulation. Hardware assertions are generally split into two types of assertions: combinational and temporal. Combinational assertions check for functional correctness at all times during the simulation. Temporal assertions check to verify sequential behavior over time. Examples include the following:</p>
<ul>
<li>Transmission outport request signal is always one-hot encoded. (combinational)</li>
<li>Transmission start signal only happens after virtual channel granted (temporal)</li>
<li>Receiver start signal goes high immediately after end signal in back-to-back transmissions (temporal)</li>
</ul>
<p>Functional coverage indicates how well the design has been checked. It is a measure of every possible scenario that is designed in the specification. Examples include the following:</p>
<ul>
<li>In ports used (ports 0,1,2,3)</li>
<li>Packet data length (All possible data lengths between 3 and 60)</li>
<li>Virtual channels (all 4 virtual channels, also check coverage between channels used at same time)</li>
</ul>
<p>Encorporating all of these elements into the verification plan while taking into account the design specification leads to a <em>golden document</em> that can be used as a guide on how to proceed forward with verification.</p>
<h2 id="uvm-overview">UVM Overview</h2>
<p>Before talking about the verification environment, it is important to know how the Universal Verification Methodology (UVM) works. UVM is a set of classes and methods that build upon the original SystemVerilog language. It allows for engineers to easily build Verification Components (VCs) and uses Object-Oriented Programming for enhanced code reusability. A basic overview is given below.</p>
<p>First, there is a UVM test class, the topmost class that configures the environment, interface, and Design Under Test (DUT). The DUT is simply an instantiation of the design being verified, and the interface is a intermediary connection between the DUT and environment.</p>
<p>The environment is composed of one or more <em>agents</em>, each with its own components. An agent will have a <em>sequencer</em> that queues up <em>sequences</em>, or test cases to be passed on to the design. The sequence will go through a <em>driver</em> and onto the interface. The agent will also have a <em>monitor</em> that captures the response from the DUT and sends that response to a <em>scoreboard</em> located in the environment, which keeps track of DUT results and ensures that the expected output was recorded.
<img src="/images/UVM_overview.png" alt="UVM Overview Picture">
Although this sounds like a complicated process with too many different elements, it is a key part of UVM. It allows for code reusability and parameterization, as well as a defined reporting system to log results. UVM utilizes Transaction Level Modeling (TLM) for communication, and often uses macros to automate the generation of UVM code.</p>
<p>Overall, UVM is a fundamental verification tool that has been widely adopted by industry. This is just a brief overview of UVM, and further reading can be found in the <a href="https://www.accellera.org/images/downloads/standards/uvm/uvm_users_guide_1.2.pdf">Accellera UVM user guide</a>.</p>
<h2 id="htax-verification-environment">HTAX Verification Environment</h2>
<p>The following sections give a brief overview of how various UVM components were implemented in the context
of verifying the HTAX communication module. Snippets will be shown throughout, and the full code can be found on <a href="https://github.com/vishnuvardhanRamesh/HTAX_verification">Github</a>.</p>
<h3 id="packets">Packets</h3>
<p>The first part of the environment involves creating HTAX packets. These packets contain information that will be sent to the DUT, and are the basis for any stimulus. These packets typically contain class member variables that can be randomized for testing, and constraints to control the randomization. An abbreviated version of a packet is showcased below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span>class htax_packet_c extends uvm_sequence_item;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//define class members
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    rand <span style="color:#66d9ef">bit</span>[<span style="color:#ae81ff">6</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] delay;
</span></span><span style="display:flex;"><span>	rand <span style="color:#66d9ef">bit</span>[<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] dest_port;
</span></span><span style="display:flex;"><span>	rand <span style="color:#66d9ef">bit</span>[VC<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] vc;
</span></span><span style="display:flex;"><span>	rand <span style="color:#66d9ef">bit</span>[<span style="color:#ae81ff">64</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] length;
</span></span><span style="display:flex;"><span>	rand <span style="color:#66d9ef">bit</span> [WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] data [];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    define UVM macros
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    define class constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//add constraints
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//Constraint 1 : delay should be between 1 and 20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	constraint delay_cons {delay inside {[<span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">20</span>]};}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Constraint 2 : dest_port should be between 0 and (PORTS-1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	constraint dest_port_cons {dest_port inside {[<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>PORTS<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]};}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Constraint 3 : VC should be valid VC request (should not be 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	constraint vc_cons {vc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>endclass: htax_packet_c
</span></span></code></pre></div><h3 id="sequences">Sequences</h3>
<p>After creating packets, we create a <em>sequences</em> to drive these packets onto the interface, which will eventually pass the signals onto the DUT. A sample sequence is shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span>class fix_dest_port_seq extends htax_base_seq;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Factory Registration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">`uvm_object_utils</span>(fix_dest_port_seq)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">function</span> new ( <span style="color:#66d9ef">string</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;fix_dest_port_seq&#34;</span>);
</span></span><span style="display:flex;"><span>        super.new(name);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">endfunction</span> <span style="color:#f92672">:</span> new
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Body task -- 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	virtual <span style="color:#66d9ef">task</span> body();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>		i<span style="color:#f92672">=</span>$urandom_range(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">`uvm_info</span>(get_type_name(),<span style="color:#e6db74">&#34;Executing fix destination port sequence with 5 transactions&#34;</span>, UVM_NONE)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//Generate a sequence with 5 packets
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">repeat</span>(<span style="color:#ae81ff">5</span>) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">`uvm_do_with</span> (req, {req.dest_port<span style="color:#f92672">==</span>i;}) <span style="color:#75715e">//fix dest_port 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">endtask</span>
</span></span><span style="display:flex;"><span>endclass <span style="color:#f92672">:</span> fix_dest_port_seq
</span></span></code></pre></div><h3 id="driver">Driver</h3>
<p>The next key component is the driver. The driver will take the data from the packet and actually send those signals to the DUT, taking into account variables given from the packet. For example, the HTAX packets have a <em>delay</em> variable, which specifies the delay before a signal is sent. The driver will take the packet delay as input, and wait however many cycles specified before sending the packet. An abbreviated driver is shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">task</span> htax_tx_driver_c<span style="color:#f92672">::</span>drive_thru_dut(htax_packet_c pkt);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">`uvm_info</span> (get_type_name(), $sformatf(<span style="color:#e6db74">&#34;Input Data Packet to DUT : </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">%s&#34;</span>, pkt.sprint()),UVM_NONE)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Wait for pkt.delay clock cycles
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">repeat</span> (pkt.delay) @(<span style="color:#66d9ef">posedge</span> htax_tx_intf.clk);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Send VC and Outport Request
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	@(<span style="color:#66d9ef">posedge</span> htax_tx_intf.clk)
</span></span><span style="display:flex;"><span>	htax_tx_intf.tx_outport_req <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#ae81ff">&#39;b0001</span> <span style="color:#f92672">&lt;&lt;</span> (pkt.dest_port); <span style="color:#75715e">//one hot encoding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	htax_tx_intf.tx_vc_req <span style="color:#f92672">=</span> pkt.vc;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Wait till htax_tx_intf.tx_vc_gnt is received
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	@(<span style="color:#66d9ef">posedge</span> <span style="color:#f92672">|</span>htax_tx_intf.tx_vc_gnt);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Wait for VC grant, then start transmission (and send first data packet)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	@(<span style="color:#66d9ef">posedge</span> htax_tx_intf.clk)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>; j<span style="color:#f92672">++</span>) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (htax_tx_intf.tx_vc_gnt[j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b1</span>) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>			htax_tx_intf.tx_sot[j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b1</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>	htax_tx_intf.tx_data <span style="color:#f92672">=</span> pkt.data[<span style="color:#ae81ff">0</span>]; <span style="color:#75715e">//driving LSB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	htax_tx_intf.tx_outport_req <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	htax_tx_intf.tx_vc_req <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Sending command signals (start/end of transmission, releasing virtual channel)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> pkt.length; i<span style="color:#f92672">++</span>) <span style="color:#66d9ef">begin</span> 
</span></span><span style="display:flex;"><span>		@(<span style="color:#66d9ef">posedge</span> htax_tx_intf.clk);
</span></span><span style="display:flex;"><span>		htax_tx_intf.tx_data <span style="color:#f92672">=</span> pkt.data[i];
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>			htax_tx_intf.tx_sot <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> (pkt.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>)) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>			htax_tx_intf.tx_release_gnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> (pkt.length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>			htax_tx_intf.tx_release_gnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>			htax_tx_intf.tx_eot <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//End of transmission
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	@(<span style="color:#66d9ef">posedge</span> htax_tx_intf.clk);
</span></span><span style="display:flex;"><span>	htax_tx_intf.tx_data <span style="color:#f92672">=</span> <span style="color:#ae81ff">&#39;x</span>; <span style="color:#75715e">//assign all X
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	htax_tx_intf.tx_eot <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">`uvm_info</span> (get_type_name(), $sformatf(<span style="color:#e6db74">&#34;Ended Driving Data Packet to DUT&#34;</span>), UVM_NONE)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">endtask</span> <span style="color:#f92672">:</span> drive_thru_dut	
</span></span></code></pre></div><h3 id="monitor-and-scoreboard">Monitor and Scoreboard</h3>
<p>Just like how the driver takes information from the packet and sends it to the DUT, a monitor can be implemented to capture the result from the DUT. This result typically gets sent to a <em>scoreboard</em>, a component that tracks results and compares them with expected values. Monitors and scoreboards often communicate with each other using Transaction Level Modeling. An abbreviated scoreboard is shown below. At a high level, this scoreboard checks to make sure that all packets received in the monitor are the exact packets delivered by the transmitter. If the queue is not empty at the end of the testbench, that means there was a mistake somewhere in the design, and the simulation will flag that as an issue.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span>    class htax_scoreboard_c extends uvm_scoreboard;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    Register scoreboard with factory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Creating queue to store the incoming TX transactions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	htax_tx_mon_packet_c port0_queue[<span style="color:#960050;background-color:#1e0010">$</span>], port1_queue[<span style="color:#960050;background-color:#1e0010">$</span>], port2_queue[<span style="color:#960050;background-color:#1e0010">$</span>], port3_queue[<span style="color:#960050;background-color:#1e0010">$</span>], cmp_pkt[<span style="color:#ae81ff">4</span>];	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Write Method - TX[0] Monitor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">function</span> <span style="color:#66d9ef">void</span> write_tx0_export(htax_tx_mon_packet_c tx_mon_packet);
</span></span><span style="display:flex;"><span>		tx_mon_packet.print();
</span></span><span style="display:flex;"><span>		push_to_queue(tx_mon_packet);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">endfunction</span> <span style="color:#f92672">:</span> write_tx0_export
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        Similar functions will be written for all TX ports
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#66d9ef">void</span> push_to_queue(htax_tx_mon_packet_c mon_pkt);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> (mon_pkt.dest_port)
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>                port0_queue.push_front(mon_pkt);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>                port1_queue.push_front(mon_pkt);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>                port2_queue.push_front(mon_pkt);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">3</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>                port3_queue.push_front(mon_pkt);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">endcase</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">endfunction</span> <span style="color:#f92672">:</span> push_to_queue
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//Write Method - RX[0] Monitor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">function</span> <span style="color:#66d9ef">void</span> write_rx0_export(htax_rx_mon_packet_c rx_mon_packet);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">`uvm_info</span>(<span style="color:#e6db74">&#34;SCOREBOARD&#34;</span>,$sformatf(<span style="color:#e6db74">&#34;Received Data Packet on Port0:&#34;</span>), UVM_NONE)
</span></span><span style="display:flex;"><span>		rx_mon_packet.print();
</span></span><span style="display:flex;"><span>		cmp_pkt[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> new ();
</span></span><span style="display:flex;"><span>		cmp_pkt[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> port0_queue.pop_back();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(cmp_pkt[<span style="color:#ae81ff">0</span>].data<span style="color:#f92672">==</span>rx_mon_packet.data)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">`uvm_info</span>(<span style="color:#e6db74">&#34;SCOREBOARD&#34;</span>,<span style="color:#e6db74">&#34;Data matches for received pkt on port 0&#34;</span>, UVM_NONE)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">`uvm_fatal</span>(<span style="color:#e6db74">&#34;SCOREBOARD&#34;</span>,<span style="color:#e6db74">&#34;Data mismatch for received pkt on port 0&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">`uvm_info</span>(<span style="color:#e6db74">&#34;SCOREBOARD&#34;</span>,<span style="color:#e6db74">&#34;Dropping pkt from queue 0&#34;</span>, UVM_NONE)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">endfunction</span> <span style="color:#f92672">:</span> write_rx0_export
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        Similar methods will be written for each monitor port
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#66d9ef">void</span> check();
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">`uvm_info</span>(<span style="color:#e6db74">&#34;SCOREBOARD&#34;</span>, <span style="color:#e6db74">&#34;End of Simulation Checking&#34;</span>, UVM_NONE)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span>(port0_queue.size()<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">`uvm_info</span>(<span style="color:#e6db74">&#34;SCOREBOARD&#34;</span>,<span style="color:#e6db74">&#34;Port 0 Queue is empty&#34;</span>, UVM_NONE)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">`uvm_fatal</span>(<span style="color:#e6db74">&#34;SCOREBOARD&#34;</span>,<span style="color:#e6db74">&#34;Port 0 Queue is non-empty at end of simulation&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        Similar statements will be made for each queue
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">endfunction</span><span style="color:#f92672">:</span> check
</span></span><span style="display:flex;"><span>endclass <span style="color:#f92672">:</span> htax_scoreboard_c
</span></span></code></pre></div><h2 id="systemverilog-assertions">SystemVerilog Assertions</h2>
<p>The verification environment described above illustrates how to send packets to the DUT, and check if the results calculated match the expected value. One other aspect of checking is to see if the design is behaving as specified in the funcitonal specification. This involves creating assertions, as described in the verification plan, to catch any critical errors when testing the design. A few example assertions used in the HTAX verification can be seen below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span>property tx_outport_req_one_hot;
</span></span><span style="display:flex;"><span>      @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">disable</span> iff(<span style="color:#f92672">!</span>rst_n)
</span></span><span style="display:flex;"><span>      (<span style="color:#f92672">|</span>tx_outport_req) <span style="color:#f92672">|-&gt;</span> $onehot(tx_outport_req);
</span></span><span style="display:flex;"><span>   endproperty
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   assert_tx_outport_req_one_hot <span style="color:#f92672">:</span> assert property(tx_outport_req_one_hot)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      $error(<span style="color:#e6db74">&#34;HTAX_TX_INF ERROR : tx_outport request is not one hot encoded&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">logic</span> tx_vc_gnt_high; <span style="color:#75715e">//checking if tx_vc_gnt is high in ANY previous clock cycle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">assign</span> tx_vc_gnt_high <span style="color:#f92672">=</span> <span style="color:#f92672">~</span>rst_n <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span> <span style="color:#f92672">:</span> (<span style="color:#f92672">|</span>tx_eot) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b1</span> <span style="color:#f92672">:</span> tx_sot <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span> <span style="color:#f92672">:</span> tx_vc_gnt_high;
</span></span><span style="display:flex;"><span>   property no_tx_eot_without_previous_tx_vc_gnt;
</span></span><span style="display:flex;"><span>      @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">disable</span> iff(<span style="color:#f92672">!</span>rst_n)
</span></span><span style="display:flex;"><span>      (tx_eot) <span style="color:#f92672">|-&gt;</span> tx_vc_gnt_high;
</span></span><span style="display:flex;"><span>   endproperty
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   assert_no_tx_eot_without_previous_tx_vc_gnt: assert property(no_tx_eot_without_previous_tx_vc_gnt)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      $error(<span style="color:#e6db74">&#34;HTAX_TX_INF ERROR : tx_eot without prev tx_vc_gnt&#34;</span>);
</span></span></code></pre></div><h2 id="technologies">Technologies</h2>
<p>SystemVerilog was used as the primary language for coding the verification environment. Cadence XCelium was used to simulate the environment, and Cadence vManager and IMC were used to gather verification metrics. Github was used to save progress throughout the duration of the project.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This verification project was done throughout a semester as part of a Hardware Verification class. Although there were many different components involved, this comprehensive environment allowed for easy regression testing. Over one thousand tests were done to find errors in the design that would be hard to find otherwise.</p>
<p>It is important to note that this is a small design. Designs in industry can be thousands of times bigger, and will require an even larger verification environment to accurately find any errors before tape-out. Because of this, many say that verification is one of the bottlenecks in chip design. There are many impressive research papers that attempt to make verification faster, such as this <a href="https://ieeexplore.ieee.org/document/10616069/">IEEE paper</a> that uses automated assertion-based coverage to reduce the manual labor required. There are also attempts to use <a href="https://dvcon-proceedings.org/wp-content/uploads/machine-learning-guided-stimulus-generation-for-functional-verification.pdf">machine learning based approaches</a> to speed up the process of verification.</p>
<p>Ultimately, hardware verification is an interesting problem that will most likely see more and more innovations in an attempt to speed up chip production in the semiconductor industry.</p>



      
    </article>
    
  </div>

        </div><footer>
  <div class="container">
    <p class="credits copyright">
      <p class="credits theme-by">
        
        
        
        &copy;
        2025
        <a href="//localhost:1313/about/">Vishnuvardhan Ramesh</a>
      </p>
  </div>
</footer></body>
</html>



      
    </article>
    
  </div>

        </div><footer>
  <div class="container">
    <p class="credits copyright">
      <p class="credits theme-by">
        
        
        
        &copy;
        2025
        <a href="//localhost:1313/about/">Vishnuvardhan Ramesh</a>
      </p>
  </div>
</footer></body>
</html>



      
    </article>
    
  </div>

        </div><footer>
  <div class="container">
    <p class="credits copyright">
      <p class="credits theme-by">
        
        
        
        &copy;
        2025
        <a href="//localhost:1313/about/">Vishnuvardhan Ramesh</a>
      </p>
  </div>
</footer></body>
</html>



      
    </article>
    
  </div>

        </div><footer>
  <div class="container">
    <p class="credits copyright">
      <p class="credits theme-by">
        
        
        
        &copy;
        2025
        <a href="//localhost:1313/about/">Vishnuvardhan Ramesh</a>
      </p>
  </div>
</footer></body>
</html>
