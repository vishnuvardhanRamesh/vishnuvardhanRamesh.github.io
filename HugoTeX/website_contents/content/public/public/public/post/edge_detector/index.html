<!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="utf-8" />

  <title></title>


  <meta name="author" content="Vishnuvardhan Ramesh"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />


<link rel="stylesheet" href="//localhost:1313/css/latex.css" />
<link rel="stylesheet" href="//localhost:1313/css/main.css" />
<script id="MathJax-script" async src="//localhost:1313/js/tex-mml-chtml.js"></script>
</head>
<body>






<div class="intro-header"></div>
<div id="content">
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <div class="postmeta">
        <span class="meta-post">
  <i class="fa fa-calendar-alt"></i>
  Jan 1, 0001
  
</span>
      </div>
      <br>
      
    <!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="utf-8" />

  <title></title>


  <meta name="author" content="Vishnuvardhan Ramesh"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />


<link rel="stylesheet" href="//localhost:1313/css/latex.css" />
<link rel="stylesheet" href="//localhost:1313/css/main.css" />
<script id="MathJax-script" async src="//localhost:1313/js/tex-mml-chtml.js"></script>
</head>
<body>






<div class="intro-header"></div>
<div id="content">
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <div class="postmeta">
        <span class="meta-post">
  <i class="fa fa-calendar-alt"></i>
  Jan 1, 0001
  
</span>
      </div>
      <br>
      
    <!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
<meta charset="utf-8" />

  <title>Canny Edge Detector - Verilog/SystemC - </title>


  <meta name="author" content="Vishnuvardhan Ramesh"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />


<link rel="stylesheet" href="//localhost:1313/css/latex.css" />
<link rel="stylesheet" href="//localhost:1313/css/main.css" />
<script id="MathJax-script" async src="//localhost:1313/js/tex-mml-chtml.js"></script>
</head>
<body>






<header>
  <nav class="navbar">
  <div class="nav">
    

    <ul class="nav-links">
      
    </ul>
  </div>
</nav>
  <div class="intro-header">
    <div class="container">
      <div class="post-heading">
        
          <h1>Canny Edge Detector - Verilog/SystemC</h1>
          
        
      </div>
    </div>
  </div>
</header>
<div id="content">
  <div class="container" role="main">
    <article class="article" class="blog-post">
      <div class="postmeta">
        <span class="meta-post">
  <i class="fa fa-calendar-alt"></i>
  Oct 15, 2024
  
</span>
      </div>
      <br>
      
    <p>Image processing is a great application for hardware design, as typical image processing algorithms involve large amounts of data processing and math operations. This project goes over a <strong>Canny Edge Detector</strong>, which takes an input image and outputs an image with all the edges outlined. This is typically done by finding sharp discontinuities in an image. This algorithm has high computation, as it utilizes Noise Reduction, Gradient Calculation, Non-Maximum Suppresion, and Hysterisis Thresholding. This creates a highly accurate output image that classifies all borders present in the image.</p>
<p>This project was first simulated in SystemC using the Anaconda SystemC package for running simulations. The circuit was then designed in Verilog using Cadence XCelium to simulate and verify the correctness of the design. The Verilog design was also verified at the gate-level design using Synopsys Design Compiler and the <a href="https://www.vlsitechnology.org/html/libraries04.html">OSU standard cell library</a>. The code for this project can be found on <a href="https://github.com/vishnuvardhanRamesh/Edge-Detector">Github</a>.</p>
<h2 id="canny-edge-circuit-algorithm">Canny Edge Circuit Algorithm</h2>
<p>The following sections detail the specific parts of this algorithm.</p>
<h3 id="noise-reduction">Noise Reduction</h3>
<p>The first step involves reducing noise in the image, using a Gaussian filter. This will slightly blur the image, but will reduce <em>false edges</em> by removing high gradient points caused by random fluctuations, while keeping the true edges visible in the image.</p>
<h3 id="gradient-calculation">Gradient Calculation</h3>
<p>To find the edge strength, we can take the Gradient of the image. This involves using Sobel operators to perform the measurement. There are two Sobel matrices, one operating in the X direction (horizontal) and one in the Y direction (vertical). These matrices are particularly good at highlighting areas of high intensity change, corresponding to edges. The gradient can be computed using the equations below.</p>
<p>
</p>
<p>Using Gx and Gy, we can then calculate the magnitude and direction. Î± is used for normalization when calculating magnitude. For direction, an approximation algorithm is used for computational efficiency.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>Magnitude <span style="color:#f92672">=</span> (abs(Gx) <span style="color:#f92672">+</span> abs(Gy)) <span style="color:#f92672">/</span> alpha
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (Gy <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>    Gx <span style="color:#f92672">=</span> Gx <span style="color:#f92672">*</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    Gy <span style="color:#f92672">=</span> Gy <span style="color:#f92672">*</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (Gx <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Gy <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0.5</span><span style="color:#f92672">*</span>Gx):
</span></span><span style="display:flex;"><span>        direction <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> (Gy <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2.5</span><span style="color:#f92672">*</span>Gx):
</span></span><span style="display:flex;"><span>        direction <span style="color:#f92672">=</span> <span style="color:#ae81ff">45</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        direction <span style="color:#f92672">=</span> <span style="color:#ae81ff">90</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Gy <span style="color:#f92672">&lt;=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span><span style="color:#f92672">*</span>Gx):
</span></span><span style="display:flex;"><span>        direction <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> (Gy <span style="color:#f92672">&lt;=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2.5</span><span style="color:#f92672">*</span>Gx):
</span></span><span style="display:flex;"><span>        direction <span style="color:#f92672">=</span> <span style="color:#ae81ff">135</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        direction <span style="color:#f92672">=</span> <span style="color:#ae81ff">90</span>  
</span></span></code></pre></div><h3 id="non-maximum-suppresion">Non-Maximum Suppresion</h3>
<p>Using the currently calculated gradients, the edges may be thick or somewhat blurry. To obtain crisp edges, the following algorithm can be used to further prune out noisy edge markings.</p>
<p><em>Note that the below algorithm is done with respect to multiple possible edge directions (0, 45, 90, 135 degrees).</em></p>
<ol>
<li>Select pixel C. Find neighbor pixels A and B based on edge direction, and the magnitudes of all pixels (calculated previously)</li>
<li>If M(C) &gt;= M(A) and M(C) &gt;= M(B), keep pixel C and discard pixels A and B by setting their magnitudes to 0</li>
<li>Otherwise, discard pixel C by setting magnitude to 0.</li>
</ol>
<h3 id="hysteresis-thresholding">Hysteresis Thresholding</h3>
<p>As seen above, some of the edges are not well defined, and most edges are not able to be clearly seen. The final step of this algorithm is to improve the image quality by further removing weak edges, and clearly defining connected edges.</p>
<ol>
<li>Define threshold levels T_high and T_low. Strong pixels are greather than T_high, weak pixels are lower than T_low. <em>Candidate</em> pixels are between the two values.</li>
<li>Keep strong pixels and discard low pixels. Look at candidate pixels and their neighboring pixels in each direction (similar to before)</li>
<li>For candidate pixels, label as <em>strong</em> if it is connected to a strong pixel, and discard otherwise.</li>
</ol>
<p>This is the final step of the algorithm that produces a clear image with well-defined edges.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Canny Edge detection is a image processing algorithm that has higher computational complexity compared to other algorithms, due to its multiple steps. It produces a high quality image, and can be implemented on hardware for high performance. This article goes over the actual implementation of the algorithm, although one should note the complexity of implementing the datapath and controller for transferring data between memory and the image processing module.</p>



      
    </article>
    
  </div>

        </div><footer>
  <div class="container">
    <p class="credits copyright">
      <p class="credits theme-by">
        
        
        
        &copy;
        2025
        <a href="//localhost:1313/about/">Vishnuvardhan Ramesh</a>
      </p>
  </div>
</footer></body>
</html>



      
    </article>
    
  </div>

        </div><footer>
  <div class="container">
    <p class="credits copyright">
      <p class="credits theme-by">
        
        
        
        &copy;
        2025
        <a href="//localhost:1313/about/">Vishnuvardhan Ramesh</a>
      </p>
  </div>
</footer></body>
</html>



      
    </article>
    
  </div>

        </div><footer>
  <div class="container">
    <p class="credits copyright">
      <p class="credits theme-by">
        
        
        
        &copy;
        2025
        <a href="//localhost:1313/about/">Vishnuvardhan Ramesh</a>
      </p>
  </div>
</footer></body>
</html>
